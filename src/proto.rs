// Copyright 2025 The Google Research Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Protobuf definitions for the ScaNN library (placeholders, assumed generated by `prost`).

use std::fmt;

#[derive(Clone, PartialEq)]
pub struct ScannAssets {
    pub assets: Vec<ScannAsset>,
}

#[derive(Clone, PartialEq)]
pub struct ScannAsset {
    pub asset_path: String,
    pub asset_type: AssetType,
}

#[derive(Clone, PartialEq)]
pub enum AssetType {
    AhCenters,
    Partitioner,
    TokenizationNpy,
    AhDatasetNpy,
    Int8DatasetNpy,
    Int8MultipliersNpy,
    Int8NormsNpy,
    DatasetNpy,
}

impl fmt::Display for ScannAssets {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        for asset in &self.assets {
            writeln!(f, "assets {{")?;
            writeln!(f, "  asset_path: \"{}\"", asset.asset_path)?;
            let asset_type_str = match asset.asset_type {
                AssetType::AhCenters => "AH_CENTERS",
                AssetType::Partitioner => "PARTITIONER",
                AssetType::TokenizationNpy => "TOKENIZATION_NPY",
                AssetType::AhDatasetNpy => "AH_DATASET_NPY",
                AssetType::Int8DatasetNpy => "INT8_DATASET_NPY",
                AssetType::Int8MultipliersNpy => "INT8_MULTIPLIERS_NPY",
                AssetType::Int8NormsNpy => "INT8_NORMS_NPY",
                AssetType::DatasetNpy => "DATASET_NPY",
            };
            writeln!(f, "  asset_type: {}", asset_type_str)?;
            writeln!(f, "}}")?;
        }
        Ok(())
    }
}

#[derive(Clone, PartialEq)]
pub struct SerializedProjection {
    pub rotation_vec: Vec<GenericFeatureVector>,
}

#[derive(Clone, PartialEq)]
pub struct GenericFeatureVector {
    pub feature_value_float: Vec<f32>,
}

impl SerializedProjection {
    pub fn new() -> Self {
        SerializedProjection {
            rotation_vec: Vec::new(),
        }
    }

    pub fn rotation_vec(&self) -> &[GenericFeatureVector] {
        &self.rotation_vec
    }

    pub fn rotation_vec_size(&self) -> usize {
        self.rotation_vec.len()
    }

    pub fn add_rotation_vec(&mut self) -> &mut GenericFeatureVector {
        self.rotation_vec.push(GenericFeatureVector {
            feature_value_float: Vec::new(),
        });
        self.rotation_vec.last_mut().unwrap()
    }

    pub fn reserve_rotation_vec(&mut self, size: usize) {
        self.rotation_vec.reserve(size);
    }
}

#[derive(Clone, PartialEq)]
pub struct PartitioningConfig {
    pub partitioning_type: PartitioningType,
    pub max_num_levels: i32,
    pub max_leaf_size: i32,
    pub database_spilling: DatabaseSpilling,
    pub max_clustering_iterations: i32,
    pub clustering_convergence_tolerance: f32,
    pub min_cluster_size: i32,
    pub clustering_seed: u64,
    pub balancing_type: BalancingType,
    pub trainer_type: TrainerType,
    pub single_machine_center_initialization: CenterInitializationType,
}

#[derive(Clone, PartialEq)]
pub struct DatabaseSpilling {
    pub spilling_type: SpillingType,
    pub replication_factor: f32,
    pub max_spill_centers: i32,
}

#[derive(Clone, PartialEq)]
pub enum PartitioningType {
    Default,
}

#[derive(Clone, PartialEq)]
pub enum SpillingType {
    Default,
}

#[derive(Clone, PartialEq)]
pub enum BalancingType {
    DefaultUnbalanced,
    GreedyBalanced,
    UnbalancedFloat32,
}

#[derive(Clone, PartialEq)]
pub enum TrainerType {
    DefaultSamplingTrainer,
    FlumeKmeansTrainer,
    PcaKmeansTrainer,
    SamplingPcaKmeansTrainer,
}

#[derive(Clone, PartialEq)]
pub enum CenterInitializationType {
    DefaultKmeansPlusPlus,
    RandomInitialization,
}

impl PartitioningConfig {
    pub fn partitioning_type(&self) -> PartitioningType {
        self.partitioning_type.clone()
    }

    pub fn max_num_levels(&self) -> i32 {
        self.max_num_levels
    }

    pub fn max_leaf_size(&self) -> i32 {
        self.max_leaf_size
    }

    pub fn database_spilling(&self) -> &DatabaseSpilling {
        &self.database_spilling
    }

    pub fn max_clustering_iterations(&self) -> i32 {
        self.max_clustering_iterations
    }

    pub fn clustering_convergence_tolerance(&self) -> f32 {
        self.clustering_convergence_tolerance
    }

    pub fn min_cluster_size(&self) -> i32 {
        self.min_cluster_size
    }

    pub fn clustering_seed(&self) -> u64 {
        self.clustering_seed
    }

    pub fn balancing_type(&self) -> BalancingType {
        self.balancing_type.clone()
    }

    pub fn trainer_type(&self) -> TrainerType {
        self.trainer_type.clone()
    }

    pub fn single_machine_center_initialization(&self) -> CenterInitializationType {
        self.single_machine_center_initialization.clone()
    }
}