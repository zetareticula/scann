{"$message_type":"diagnostic","message":"file not found for module `trees`","code":{"code":"E0583","explanation":"A file wasn't found for an out-of-line module.\n\nErroneous code example:\n\n```compile_fail,E0583\nmod file_that_doesnt_exist; // error: file not found for module\n\nfn main() {}\n```\n\nPlease be sure that a file corresponding to the module exists. If you\nwant to use a module named `file_that_doesnt_exist`, you need to have a file\nnamed `file_that_doesnt_exist.rs` or `file_that_doesnt_exist/mod.rs` in the\nsame directory.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":815,"byte_end":829,"line_start":24,"line_end":24,"column_start":1,"column_end":15,"is_primary":true,"text":[{"text":"pub mod trees;","highlight_start":1,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"to create the module `trees`, create file \"src/trees.rs\" or \"src/trees/mod.rs\"","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"if there is a `mod trees` elsewhere in the crate already, import it with `use crate::...` instead","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0583]\u001b[0m\u001b[0m\u001b[1m: file not found for module `trees`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:24:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub mod trees;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: to create the module `trees`, create file \"src/trees.rs\" or \"src/trees/mod.rs\"\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: if there is a `mod trees` elsewhere in the crate already, import it with `use crate::...` instead\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the name `CosineDistance` is defined multiple times","code":{"code":"E0428","explanation":"A type or module has been defined more than once.\n\nErroneous code example:\n\n```compile_fail,E0428\nstruct Bar;\nstruct Bar; // error: duplicate definition of value `Bar`\n```\n\nPlease verify you didn't misspell the type/module's name or remove/rename the\nduplicated one. Example:\n\n```\nstruct Bar;\nstruct Bar2; // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":1791,"byte_end":1808,"line_start":52,"line_end":52,"column_start":9,"column_end":26,"is_primary":true,"text":[{"text":"        pub struct $name;","highlight_start":9,"highlight_end":26}],"label":"`CosineDistance` redefined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/distance_measures.rs","byte_start":2825,"byte_end":2865,"line_start":83,"line_end":83,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"define_distance_measure!(CosineDistance);","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"define_distance_measure!","def_site_span":{"file_name":"src/distance_measures.rs","byte_start":1721,"byte_end":1757,"line_start":50,"line_end":50,"column_start":1,"column_end":37,"is_primary":false,"text":[{"text":"macro_rules! define_distance_measure {","highlight_start":1,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/distance_measures.rs","byte_start":744,"byte_end":770,"line_start":21,"line_end":21,"column_start":1,"column_end":27,"is_primary":false,"text":[{"text":"pub struct CosineDistance;","highlight_start":1,"highlight_end":27}],"label":"previous definition of the type `CosineDistance` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`CosineDistance` must be defined only once in the type namespace of this module","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0428]\u001b[0m\u001b[0m\u001b[1m: the name `CosineDistance` is defined multiple times\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:52:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct CosineDistance;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mprevious definition of the type `CosineDistance` here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        pub struct $name;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`CosineDistance` redefined here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m83\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mdefine_distance_measure!(CosineDistance);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `CosineDistance` must be defined only once in the type namespace of this module\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `define_distance_measure` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unresolved import `super::utils`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":666,"byte_end":671,"line_start":17,"line_end":17,"column_start":20,"column_end":25,"is_primary":true,"text":[{"text":"use super::{proto, utils, ScannError};","highlight_start":20,"highlight_end":25}],"label":"no `utils` in the root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a similar name exists in the module","code":null,"level":"help","spans":[{"file_name":"src/distance_measures.rs","byte_start":666,"byte_end":671,"line_start":17,"line_end":17,"column_start":20,"column_end":25,"is_primary":true,"text":[{"text":"use super::{proto, utils, ScannError};","highlight_start":20,"highlight_end":25}],"label":null,"suggested_replacement":"util","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved import `super::utils`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:17:20\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse super::{proto, utils, ScannError};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `utils` in the root\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: a similar name exists in the module: `util`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unresolved imports `super::failed_precondition_error`, `super::invalid_argument_error`, `super::utils`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src/projection.rs","byte_start":683,"byte_end":708,"line_start":17,"line_end":17,"column_start":13,"column_end":38,"is_primary":true,"text":[{"text":"use super::{failed_precondition_error, invalid_argument_error, proto, utils, ScannError};","highlight_start":13,"highlight_end":38}],"label":"no `failed_precondition_error` in the root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/projection.rs","byte_start":710,"byte_end":732,"line_start":17,"line_end":17,"column_start":40,"column_end":62,"is_primary":true,"text":[{"text":"use super::{failed_precondition_error, invalid_argument_error, proto, utils, ScannError};","highlight_start":40,"highlight_end":62}],"label":"no `invalid_argument_error` in the root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/projection.rs","byte_start":741,"byte_end":746,"line_start":17,"line_end":17,"column_start":71,"column_end":76,"is_primary":true,"text":[{"text":"use super::{failed_precondition_error, invalid_argument_error, proto, utils, ScannError};","highlight_start":71,"highlight_end":76}],"label":"no `utils` in the root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a similar name exists in the module","code":null,"level":"help","spans":[{"file_name":"src/projection.rs","byte_start":741,"byte_end":746,"line_start":17,"line_end":17,"column_start":71,"column_end":76,"is_primary":true,"text":[{"text":"use super::{failed_precondition_error, invalid_argument_error, proto, utils, ScannError};","highlight_start":71,"highlight_end":76}],"label":null,"suggested_replacement":"util","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved imports `super::failed_precondition_error`, `super::invalid_argument_error`, `super::utils`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/projection.rs:17:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse super::{failed_precondition_error, invalid_argument_error, proto, utils, ScannError};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `utils` in the root\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: a similar name exists in the module: `util`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `invalid_argument_error` in the root\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `failed_precondition_error` in the root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unresolved import `super::utils`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src/retrieval.rs","byte_start":707,"byte_end":712,"line_start":17,"line_end":17,"column_start":39,"column_end":44,"is_primary":true,"text":[{"text":"use super::{distance_measures, proto, utils, ScannError};","highlight_start":39,"highlight_end":44}],"label":"no `utils` in the root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"unresolved item `crate::projection::pca_utils::utils` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"a similar name exists in the module","code":null,"level":"help","spans":[{"file_name":"src/retrieval.rs","byte_start":707,"byte_end":712,"line_start":17,"line_end":17,"column_start":39,"column_end":44,"is_primary":true,"text":[{"text":"use super::{distance_measures, proto, utils, ScannError};","highlight_start":39,"highlight_end":44}],"label":null,"suggested_replacement":"util","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved import `super::utils`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retrieval.rs:17:39\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse super::{distance_measures, proto, utils, ScannError};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `utils` in the root\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: a similar name exists in the module: `util`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: unresolved item `crate::projection::pca_utils::utils` exists but is inaccessible\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unresolved import `super::utils`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src/retro/attention.rs","byte_start":727,"byte_end":739,"line_start":20,"line_end":20,"column_start":5,"column_end":17,"is_primary":true,"text":[{"text":"use super::utils;","highlight_start":5,"highlight_end":17}],"label":"no `utils` in `retro`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved import `super::utils`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retro/attention.rs:20:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m20\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse super::utils;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `utils` in `retro`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared crate or module `rand`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/retro/embeddings.rs","byte_start":692,"byte_end":696,"line_start":18,"line_end":18,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"use rand::distributions::{Distribution, Normal};","highlight_start":5,"highlight_end":9}],"label":"use of undeclared crate or module `rand`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of undeclared crate or module `rand`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retro/embeddings.rs:18:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse rand::distributions::{Distribution, Normal};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `rand`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unresolved import `super::utils`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src/retro/decoder.rs","byte_start":720,"byte_end":725,"line_start":20,"line_end":20,"column_start":33,"column_end":38,"is_primary":true,"text":[{"text":"use super::{attention, encoder, utils};","highlight_start":33,"highlight_end":38}],"label":"no `utils` in `retro`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"unresolved item `crate::projection::pca_utils::utils` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved import `super::utils`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retro/decoder.rs:20:33\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m20\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse super::{attention, encoder, utils};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `utils` in `retro`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: unresolved item `crate::projection::pca_utils::utils` exists but is inaccessible\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unresolved import `super::utils`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src/retro/encoder.rs","byte_start":711,"byte_end":716,"line_start":20,"line_end":20,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"use super::{attention, utils};","highlight_start":24,"highlight_end":29}],"label":"no `utils` in `retro`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"unresolved item `crate::projection::pca_utils::utils` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved import `super::utils`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retro/encoder.rs:20:24\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m20\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse super::{attention, utils};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `utils` in `retro`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: unresolved item `crate::projection::pca_utils::utils` exists but is inaccessible\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unresolved import `super::utils`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src/retro/model.rs","byte_start":724,"byte_end":729,"line_start":20,"line_end":20,"column_start":43,"column_end":48,"is_primary":true,"text":[{"text":"use super::{decoder, embeddings, encoder, utils};","highlight_start":43,"highlight_end":48}],"label":"no `utils` in `retro`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"unresolved item `crate::projection::pca_utils::utils` exists but is inaccessible","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved import `super::utils`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retro/model.rs:20:43\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m20\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse super::{decoder, embeddings, encoder, utils};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `utils` in `retro`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: unresolved item `crate::projection::pca_utils::utils` exists but is inaccessible\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unresolved import `trees::KMeansTreeTrainingOptions`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":1114,"byte_end":1146,"line_start":33,"line_end":33,"column_start":9,"column_end":41,"is_primary":true,"text":[{"text":"pub use trees::KMeansTreeTrainingOptions;","highlight_start":9,"highlight_end":41}],"label":"no `KMeansTreeTrainingOptions` in `trees`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved import `trees::KMeansTreeTrainingOptions`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:33:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m33\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub use trees::KMeansTreeTrainingOptions;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `KMeansTreeTrainingOptions` in `trees`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unresolved import `utils`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":1156,"byte_end":1161,"line_start":34,"line_end":34,"column_start":9,"column_end":14,"is_primary":true,"text":[{"text":"pub use utils::{DenseDataset, DatapointPtr, ScannError};","highlight_start":9,"highlight_end":14}],"label":"use of undeclared crate or module `utils`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a crate or module with a similar name","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":1156,"byte_end":1161,"line_start":34,"line_end":34,"column_start":9,"column_end":14,"is_primary":true,"text":[{"text":"pub use utils::{DenseDataset, DatapointPtr, ScannError};","highlight_start":9,"highlight_end":14}],"label":null,"suggested_replacement":"util","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved import `utils`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:34:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub use utils::{DenseDataset, DatapointPtr, ScannError};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `utils`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a crate or module with a similar name\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub use \u001b[0m\u001b[0m\u001b[38;5;10mutil\u001b[0m\u001b[0m::{DenseDataset, DatapointPtr, ScannError};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[38;5;10m~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unresolved import `ngalgebra`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":713,"byte_end":722,"line_start":19,"line_end":19,"column_start":5,"column_end":14,"is_primary":true,"text":[{"text":"use ngalgebra::{DVector, Vector};","highlight_start":5,"highlight_end":14}],"label":"use of undeclared crate or module `ngalgebra`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a crate or module with a similar name","code":null,"level":"help","spans":[{"file_name":"src/distance_measures.rs","byte_start":713,"byte_end":722,"line_start":19,"line_end":19,"column_start":5,"column_end":14,"is_primary":true,"text":[{"text":"use ngalgebra::{DVector, Vector};","highlight_start":5,"highlight_end":14}],"label":null,"suggested_replacement":"nalgebra","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved import `ngalgebra`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:19:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse ngalgebra::{DVector, Vector};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `ngalgebra`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a crate or module with a similar name\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse \u001b[0m\u001b[0m\u001b[38;5;10mnalgebra\u001b[0m\u001b[0m::{DVector, Vector};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `AssetType` in `proto`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/assets.rs","byte_start":1599,"byte_end":1608,"line_start":50,"line_end":50,"column_start":72,"column_end":81,"is_primary":true,"text":[{"text":"    add_if_exists(&mut assets, artifacts_dir, \"ah_codebook.pb\", proto::AssetType::AhCenters);","highlight_start":72,"highlight_end":81}],"label":"could not find `AssetType` in `proto`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `AssetType` in `proto`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/assets.rs:50:72\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m50\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    add_if_exists(&mut assets, artifacts_dir, \"ah_codebook.pb\", proto::AssetType::AhCenters);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `AssetType` in `proto`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `AssetType` in `proto`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/assets.rs","byte_start":1704,"byte_end":1713,"line_start":51,"line_end":51,"column_start":83,"column_end":92,"is_primary":true,"text":[{"text":"    add_if_exists(&mut assets, artifacts_dir, \"serialized_partitioner.pb\", proto::AssetType::Partitioner);","highlight_start":83,"highlight_end":92}],"label":"could not find `AssetType` in `proto`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `AssetType` in `proto`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/assets.rs:51:83\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m51\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    add_if_exists(&mut assets, artifacts_dir, \"serialized_partitioner.pb\", proto::AssetType::Partitioner);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `AssetType` in `proto`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `AssetType` in `proto`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/assets.rs","byte_start":1808,"byte_end":1817,"line_start":52,"line_end":52,"column_start":80,"column_end":89,"is_primary":true,"text":[{"text":"    add_if_exists(&mut assets, artifacts_dir, \"datapoint_to_token.npy\", proto::AssetType::TokenizationNpy);","highlight_start":80,"highlight_end":89}],"label":"could not find `AssetType` in `proto`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `AssetType` in `proto`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/assets.rs:52:80\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    add_if_exists(&mut assets, artifacts_dir, \"datapoint_to_token.npy\", proto::AssetType::TokenizationNpy);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `AssetType` in `proto`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `AssetType` in `proto`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/assets.rs","byte_start":1912,"byte_end":1921,"line_start":53,"line_end":53,"column_start":76,"column_end":85,"is_primary":true,"text":[{"text":"    add_if_exists(&mut assets, artifacts_dir, \"hashed_dataset.npy\", proto::AssetType::AhDatasetNpy);","highlight_start":76,"highlight_end":85}],"label":"could not find `AssetType` in `proto`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `AssetType` in `proto`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/assets.rs:53:76\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m53\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    add_if_exists(&mut assets, artifacts_dir, \"hashed_dataset.npy\", proto::AssetType::AhDatasetNpy);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `AssetType` in `proto`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `AssetType` in `proto`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/assets.rs","byte_start":2011,"byte_end":2020,"line_start":54,"line_end":54,"column_start":74,"column_end":83,"is_primary":true,"text":[{"text":"    add_if_exists(&mut assets, artifacts_dir, \"int8_dataset.npy\", proto::AssetType::Int8DatasetNpy);","highlight_start":74,"highlight_end":83}],"label":"could not find `AssetType` in `proto`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `AssetType` in `proto`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/assets.rs:54:74\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    add_if_exists(&mut assets, artifacts_dir, \"int8_dataset.npy\", proto::AssetType::Int8DatasetNpy);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `AssetType` in `proto`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `AssetType` in `proto`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/assets.rs","byte_start":2116,"byte_end":2125,"line_start":55,"line_end":55,"column_start":78,"column_end":87,"is_primary":true,"text":[{"text":"    add_if_exists(&mut assets, artifacts_dir, \"int8_multipliers.npy\", proto::AssetType::Int8MultipliersNpy);","highlight_start":78,"highlight_end":87}],"label":"could not find `AssetType` in `proto`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `AssetType` in `proto`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/assets.rs:55:78\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m55\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    add_if_exists(&mut assets, artifacts_dir, \"int8_multipliers.npy\", proto::AssetType::Int8MultipliersNpy);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `AssetType` in `proto`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `AssetType` in `proto`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/assets.rs","byte_start":2217,"byte_end":2226,"line_start":56,"line_end":56,"column_start":70,"column_end":79,"is_primary":true,"text":[{"text":"    add_if_exists(&mut assets, artifacts_dir, \"dp_norms.npy\", proto::AssetType::Int8NormsNpy);","highlight_start":70,"highlight_end":79}],"label":"could not find `AssetType` in `proto`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `AssetType` in `proto`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/assets.rs:56:70\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    add_if_exists(&mut assets, artifacts_dir, \"dp_norms.npy\", proto::AssetType::Int8NormsNpy);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `AssetType` in `proto`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `AssetType` in `proto`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/assets.rs","byte_start":2311,"byte_end":2320,"line_start":57,"line_end":57,"column_start":69,"column_end":78,"is_primary":true,"text":[{"text":"    add_if_exists(&mut assets, artifacts_dir, \"dataset.npy\", proto::AssetType::DatasetNpy);","highlight_start":69,"highlight_end":78}],"label":"could not find `AssetType` in `proto`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `AssetType` in `proto`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/assets.rs:57:69\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    add_if_exists(&mut assets, artifacts_dir, \"dataset.npy\", proto::AssetType::DatasetNpy);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `AssetType` in `proto`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `SerializedProjection` in `proto`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/projection.rs","byte_start":10337,"byte_end":10357,"line_start":296,"line_end":296,"column_start":33,"column_end":53,"is_primary":true,"text":[{"text":"        let mut result = proto::SerializedProjection::new();","highlight_start":33,"highlight_end":53}],"label":"could not find `SerializedProjection` in `proto`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `SerializedProjection` in `proto`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/projection.rs:296:33\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m296\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut result = proto::SerializedProjection::new();\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `SerializedProjection` in `proto`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `utils` in `super`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/retro/embeddings.rs","byte_start":1465,"byte_end":1470,"line_start":39,"line_end":39,"column_start":35,"column_end":40,"is_primary":true,"text":[{"text":"                return Err(super::utils::invalid_argument_error(&format!(","highlight_start":35,"highlight_end":40}],"label":"could not find `utils` in `super`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `utils` in `super`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retro/embeddings.rs:39:35\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m39\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                return Err(super::utils::invalid_argument_error(&format!(\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `utils` in `super`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `utils` in `super`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/retro/embeddings.rs","byte_start":2337,"byte_end":2342,"line_start":66,"line_end":66,"column_start":31,"column_end":36,"is_primary":true,"text":[{"text":"            return Err(super::utils::invalid_argument_error(&format!(","highlight_start":31,"highlight_end":36}],"label":"could not find `utils` in `super`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `utils` in `super`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retro/embeddings.rs:66:31\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m66\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            return Err(super::utils::invalid_argument_error(&format!(\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `utils` in `super`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `ScannAssets` in module `proto`","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/assets.rs","byte_start":935,"byte_end":946,"line_start":29,"line_end":29,"column_start":20,"column_end":31,"is_primary":true,"text":[{"text":") -> Result<proto::ScannAssets, Box<dyn Error>> {","highlight_start":20,"highlight_end":31}],"label":"not found in `proto`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `ScannAssets` in module `proto`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/assets.rs:29:20\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m) -> Result<proto::ScannAssets, Box<dyn Error>> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in `proto`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `ScannAssets` in module `proto`","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/assets.rs","byte_start":1042,"byte_end":1053,"line_start":31,"line_end":31,"column_start":29,"column_end":40,"is_primary":true,"text":[{"text":"    let mut assets = proto::ScannAssets {","highlight_start":29,"highlight_end":40}],"label":"not found in `proto`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0422]\u001b[0m\u001b[0m\u001b[1m: cannot find struct, variant or union type `ScannAssets` in module `proto`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/assets.rs:31:29\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut assets = proto::ScannAssets {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in `proto`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `ScannAssets` in module `proto`","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/assets.rs","byte_start":1142,"byte_end":1153,"line_start":36,"line_end":36,"column_start":29,"column_end":40,"is_primary":true,"text":[{"text":"        assets: &mut proto::ScannAssets,","highlight_start":29,"highlight_end":40}],"label":"not found in `proto`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `ScannAssets` in module `proto`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/assets.rs:36:29\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m36\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assets: &mut proto::ScannAssets,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in `proto`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `AssetType` in module `proto`","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/assets.rs","byte_start":1236,"byte_end":1245,"line_start":39,"line_end":39,"column_start":28,"column_end":37,"is_primary":true,"text":[{"text":"        asset_type: proto::AssetType,","highlight_start":28,"highlight_end":37}],"label":"not found in `proto`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `AssetType` in module `proto`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/assets.rs:39:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m39\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        asset_type: proto::AssetType,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in `proto`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `ScannAsset` in module `proto`","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/assets.rs","byte_start":1384,"byte_end":1394,"line_start":43,"line_end":43,"column_start":39,"column_end":49,"is_primary":true,"text":[{"text":"            assets.assets.push(proto::ScannAsset {","highlight_start":39,"highlight_end":49}],"label":"not found in `proto`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0422]\u001b[0m\u001b[0m\u001b[1m: cannot find struct, variant or union type `ScannAsset` in module `proto`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/assets.rs:43:39\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m43\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            assets.assets.push(proto::ScannAsset {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in `proto`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `DistanceMeasureConfig` in module `proto`","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":3265,"byte_end":3286,"line_start":92,"line_end":92,"column_start":45,"column_end":66,"is_primary":true,"text":[{"text":"pub fn get_distance_measure(config: &proto::DistanceMeasureConfig) -> Result<Box<dyn DistanceMeasure>, Box<dyn Error>> {","highlight_start":45,"highlight_end":66}],"label":"not found in `proto`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `DistanceMeasureConfig` in module `proto`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:92:45\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m92\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn get_distance_measure(config: &proto::DistanceMeasureConfig) -> Result<Box<dyn DistanceMeasure>, Box<dyn Error>> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in `proto`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `SerializedProjection` in module `proto`","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/projection.rs","byte_start":6525,"byte_end":6545,"line_start":203,"line_end":203,"column_start":40,"column_end":60,"is_primary":true,"text":[{"text":"        serialized_projection: &proto::SerializedProjection,","highlight_start":40,"highlight_end":60}],"label":"not found in `proto`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `SerializedProjection` in module `proto`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/projection.rs:203:40\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m203\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        serialized_projection: &proto::SerializedProjection,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in `proto`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `SerializedProjection` in module `proto`","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/projection.rs","byte_start":10194,"byte_end":10214,"line_start":292,"line_end":292,"column_start":55,"column_end":75,"is_primary":true,"text":[{"text":"    pub fn serialize_to_proto(&self) -> Option<proto::SerializedProjection> {","highlight_start":55,"highlight_end":75}],"label":"not found in `proto`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `SerializedProjection` in module `proto`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/projection.rs:292:55\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m292\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn serialize_to_proto(&self) -> Option<proto::SerializedProjection> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in `proto`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `GenericFeatureVector` in module `proto`","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/projection.rs","byte_start":10676,"byte_end":10696,"line_start":306,"line_end":306,"column_start":36,"column_end":56,"is_primary":true,"text":[{"text":"    pub fn to_gfv(&self) -> proto::GenericFeatureVector {","highlight_start":36,"highlight_end":56}],"label":"not found in `proto`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `GenericFeatureVector` in module `proto`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/projection.rs:306:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m306\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn to_gfv(&self) -> proto::GenericFeatureVector {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in `proto`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `GenericFeatureVector` in module `proto`","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/projection.rs","byte_start":10714,"byte_end":10734,"line_start":307,"line_end":307,"column_start":16,"column_end":36,"is_primary":true,"text":[{"text":"        proto::GenericFeatureVector {","highlight_start":16,"highlight_end":36}],"label":"not found in `proto`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0422]\u001b[0m\u001b[0m\u001b[1m: cannot find struct, variant or union type `GenericFeatureVector` in module `proto`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/projection.rs:307:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m307\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        proto::GenericFeatureVector {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in `proto`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `proto`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/retrieval.rs","byte_start":700,"byte_end":705,"line_start":17,"line_end":17,"column_start":32,"column_end":37,"is_primary":true,"text":[{"text":"use super::{distance_measures, proto, utils, ScannError};","highlight_start":32,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/retrieval.rs","byte_start":698,"byte_end":705,"line_start":17,"line_end":17,"column_start":30,"column_end":37,"is_primary":true,"text":[{"text":"use super::{distance_measures, proto, utils, ScannError};","highlight_start":30,"highlight_end":37}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `proto`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retrieval.rs:17:32\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse super::{distance_measures, proto, utils, ScannError};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `DVector`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/retro/embeddings.rs","byte_start":678,"byte_end":685,"line_start":17,"line_end":17,"column_start":25,"column_end":32,"is_primary":true,"text":[{"text":"use nalgebra::{DMatrix, DVector};","highlight_start":25,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/retro/embeddings.rs","byte_start":676,"byte_end":685,"line_start":17,"line_end":17,"column_start":23,"column_end":32,"is_primary":true,"text":[{"text":"use nalgebra::{DMatrix, DVector};","highlight_start":23,"highlight_end":32}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/retro/embeddings.rs","byte_start":668,"byte_end":669,"line_start":17,"line_end":17,"column_start":15,"column_end":16,"is_primary":true,"text":[{"text":"use nalgebra::{DMatrix, DVector};","highlight_start":15,"highlight_end":16}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/retro/embeddings.rs","byte_start":685,"byte_end":686,"line_start":17,"line_end":17,"column_start":32,"column_end":33,"is_primary":true,"text":[{"text":"use nalgebra::{DMatrix, DVector};","highlight_start":32,"highlight_end":33}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `DVector`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retro/embeddings.rs:17:25\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nalgebra::{DMatrix, DVector};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `DVector`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/util.rs","byte_start":679,"byte_end":686,"line_start":17,"line_end":17,"column_start":25,"column_end":32,"is_primary":true,"text":[{"text":"use nalgebra::{DMatrix, DVector};","highlight_start":25,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/util.rs","byte_start":677,"byte_end":686,"line_start":17,"line_end":17,"column_start":23,"column_end":32,"is_primary":true,"text":[{"text":"use nalgebra::{DMatrix, DVector};","highlight_start":23,"highlight_end":32}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/util.rs","byte_start":669,"byte_end":670,"line_start":17,"line_end":17,"column_start":15,"column_end":16,"is_primary":true,"text":[{"text":"use nalgebra::{DMatrix, DVector};","highlight_start":15,"highlight_end":16}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/util.rs","byte_start":686,"byte_end":687,"line_start":17,"line_end":17,"column_start":32,"column_end":33,"is_primary":true,"text":[{"text":"use nalgebra::{DMatrix, DVector};","highlight_start":32,"highlight_end":33}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `DVector`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/util.rs:17:25\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse nalgebra::{DMatrix, DVector};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"conflicting implementations of trait `DistanceMeasure` for type `distance_measures::CosineDistance`","code":{"code":"E0119","explanation":"There are conflicting trait implementations for the same type.\n\nErroneous code example:\n\n```compile_fail,E0119\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo {\n    value: usize\n}\n\nimpl MyTrait for Foo { // error: conflicting implementations of trait\n                       //        `MyTrait` for type `Foo`\n    fn get(&self) -> usize { self.value }\n}\n```\n\nWhen looking for the implementation for the trait, the compiler finds\nboth the `impl<T> MyTrait for T` where T is all types and the `impl\nMyTrait for Foo`. Since a trait cannot be implemented multiple times,\nthis is an error. So, when you write:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nThis makes the trait implemented on all types in the scope. So if you\ntry to implement it on another one after that, the implementations will\nconflict. Example:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo;\n\nfn main() {\n    let f = Foo;\n\n    f.get(); // the trait is implemented so we can use it\n}\n```\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":853,"byte_end":892,"line_start":29,"line_end":29,"column_start":1,"column_end":40,"is_primary":false,"text":[{"text":"impl DistanceMeasure for CosineDistance {","highlight_start":1,"highlight_end":40}],"label":"first implementation here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1921,"byte_end":1951,"line_start":60,"line_end":60,"column_start":9,"column_end":39,"is_primary":true,"text":[{"text":"        impl DistanceMeasure for $name {","highlight_start":9,"highlight_end":39}],"label":"conflicting implementation for `distance_measures::CosineDistance`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/distance_measures.rs","byte_start":2825,"byte_end":2865,"line_start":83,"line_end":83,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"define_distance_measure!(CosineDistance);","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"define_distance_measure!","def_site_span":{"file_name":"src/distance_measures.rs","byte_start":1721,"byte_end":1757,"line_start":50,"line_end":50,"column_start":1,"column_end":37,"is_primary":false,"text":[{"text":"macro_rules! define_distance_measure {","highlight_start":1,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0119]\u001b[0m\u001b[0m\u001b[1m: conflicting implementations of trait `DistanceMeasure` for type `distance_measures::CosineDistance`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:60:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl DistanceMeasure for CosineDistance {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mfirst implementation here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m60\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        impl DistanceMeasure for $name {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconflicting implementation for `distance_measures::CosineDistance`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m83\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mdefine_distance_measure!(CosineDistance);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `define_distance_measure` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":3302,"byte_end":3321,"line_start":92,"line_end":92,"column_start":82,"column_end":101,"is_primary":true,"text":[{"text":"pub fn get_distance_measure(config: &proto::DistanceMeasureConfig) -> Result<Box<dyn DistanceMeasure>, Box<dyn Error>> {","highlight_start":82,"highlight_end":101}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:92:82\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m92\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn get_distance_measure(config: &proto::DistanceMeasureConfig) -> Result<Box<dyn DistanceMeasure>, Box<dyn Error>> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":3675,"byte_end":3694,"line_start":101,"line_end":101,"column_start":63,"column_end":82,"is_primary":true,"text":[{"text":"pub fn get_distance_measure_by_name(name: &str) -> Result<Box<dyn DistanceMeasure>, Box<dyn Error>> {","highlight_start":63,"highlight_end":82}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:101:63\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn get_distance_measure_by_name(name: &str) -> Result<Box<dyn DistanceMeasure>, Box<dyn Error>> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/retrieval.rs","byte_start":867,"byte_end":905,"line_start":23,"line_end":23,"column_start":27,"column_end":65,"is_primary":true,"text":[{"text":"    distance_measure: Box<dyn distance_measures::DistanceMeasure>,","highlight_start":27,"highlight_end":65}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retrieval.rs:23:27\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m23\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    distance_measure: Box<dyn distance_measures::DistanceMeasure>,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/retrieval.rs","byte_start":1036,"byte_end":1074,"line_start":30,"line_end":30,"column_start":31,"column_end":69,"is_primary":true,"text":[{"text":"        distance_measure: Box<dyn distance_measures::DistanceMeasure>,","highlight_start":31,"highlight_end":69}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retrieval.rs:30:31\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m30\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        distance_measure: Box<dyn distance_measures::DistanceMeasure>,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"duplicate definitions with name `new`","code":{"code":"E0592","explanation":"This error occurs when you defined methods or associated functions with same\nname.\n\nErroneous code example:\n\n```compile_fail,E0592\nstruct Foo;\n\nimpl Foo {\n    fn bar() {} // previous definition here\n}\n\nimpl Foo {\n    fn bar() {} // duplicate definition here\n}\n```\n\nA similar error is E0201. The difference is whether there is one declaration\nblock or not. To avoid this error, you must give each `fn` a unique name.\n\n```\nstruct Foo;\n\nimpl Foo {\n    fn bar() {}\n}\n\nimpl Foo {\n    fn baz() {} // define with different name\n}\n```\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":798,"byte_end":818,"line_start":24,"line_end":24,"column_start":5,"column_end":25,"is_primary":true,"text":[{"text":"    pub fn new() -> Self {","highlight_start":5,"highlight_end":25}],"label":"duplicate definitions for `new`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1843,"byte_end":1863,"line_start":55,"line_end":55,"column_start":13,"column_end":33,"is_primary":false,"text":[{"text":"            pub fn new() -> Self {","highlight_start":13,"highlight_end":33}],"label":"other definition for `new`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/distance_measures.rs","byte_start":2825,"byte_end":2865,"line_start":83,"line_end":83,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"define_distance_measure!(CosineDistance);","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"define_distance_measure!","def_site_span":{"file_name":"src/distance_measures.rs","byte_start":1721,"byte_end":1757,"line_start":50,"line_end":50,"column_start":1,"column_end":37,"is_primary":false,"text":[{"text":"macro_rules! define_distance_measure {","highlight_start":1,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0592]\u001b[0m\u001b[0m\u001b[1m: duplicate definitions with name `new`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:24:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new() -> Self {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mduplicate definitions for `new`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m55\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            pub fn new() -> Self {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mother definition for `new`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":3403,"byte_end":3406,"line_start":94,"line_end":94,"column_start":16,"column_end":19,"is_primary":true,"text":[{"text":"        return Err(Box::new(ScannError {","highlight_start":16,"highlight_end":19}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:94:16\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m94\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        return Err(Box::new(ScannError {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":3554,"byte_end":3609,"line_start":98,"line_end":98,"column_start":5,"column_end":60,"is_primary":true,"text":[{"text":"    get_distance_measure_by_name(config.distance_measure())","highlight_start":5,"highlight_end":60}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:98:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m98\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    get_distance_measure_by_name(config.distance_measure())\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":3767,"byte_end":3802,"line_start":103,"line_end":103,"column_start":36,"column_end":71,"is_primary":true,"text":[{"text":"        \"DotProductDistance\" => Ok(Box::new(DotProductDistance::new())),","highlight_start":36,"highlight_end":71}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `Box<DotProductDistance>` to `Box<dyn DistanceMeasure>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:103:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m103\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"DotProductDistance\" => Ok(Box::new(DotProductDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for the cast from `Box<DotProductDistance>` to `Box<dyn DistanceMeasure>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":3764,"byte_end":3766,"line_start":103,"line_end":103,"column_start":33,"column_end":35,"is_primary":true,"text":[{"text":"        \"DotProductDistance\" => Ok(Box::new(DotProductDistance::new())),","highlight_start":33,"highlight_end":35}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:103:33\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m103\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"DotProductDistance\" => Ok(Box::new(DotProductDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":3764,"byte_end":3803,"line_start":103,"line_end":103,"column_start":33,"column_end":72,"is_primary":true,"text":[{"text":"        \"DotProductDistance\" => Ok(Box::new(DotProductDistance::new())),","highlight_start":33,"highlight_end":72}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:103:33\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m103\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"DotProductDistance\" => Ok(Box::new(DotProductDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":3846,"byte_end":3887,"line_start":104,"line_end":104,"column_start":42,"column_end":83,"is_primary":true,"text":[{"text":"        \"BinaryDotProductDistance\" => Ok(Box::new(BinaryDotProductDistance::new())),","highlight_start":42,"highlight_end":83}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `Box<BinaryDotProductDistance>` to `Box<dyn DistanceMeasure>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:104:42\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m104\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"BinaryDotProductDistance\" => Ok(Box::new(BinaryDotProductDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for the cast from `Box<BinaryDotProductDistance>` to `Box<dyn DistanceMeasure>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":3843,"byte_end":3845,"line_start":104,"line_end":104,"column_start":39,"column_end":41,"is_primary":true,"text":[{"text":"        \"BinaryDotProductDistance\" => Ok(Box::new(BinaryDotProductDistance::new())),","highlight_start":39,"highlight_end":41}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:104:39\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m104\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"BinaryDotProductDistance\" => Ok(Box::new(BinaryDotProductDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":3843,"byte_end":3888,"line_start":104,"line_end":104,"column_start":39,"column_end":84,"is_primary":true,"text":[{"text":"        \"BinaryDotProductDistance\" => Ok(Box::new(BinaryDotProductDistance::new())),","highlight_start":39,"highlight_end":84}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:104:39\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m104\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"BinaryDotProductDistance\" => Ok(Box::new(BinaryDotProductDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":3928,"byte_end":3966,"line_start":105,"line_end":105,"column_start":39,"column_end":77,"is_primary":true,"text":[{"text":"        \"AbsDotProductDistance\" => Ok(Box::new(AbsDotProductDistance::new())),","highlight_start":39,"highlight_end":77}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `Box<AbsDotProductDistance>` to `Box<dyn DistanceMeasure>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:105:39\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m105\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"AbsDotProductDistance\" => Ok(Box::new(AbsDotProductDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for the cast from `Box<AbsDotProductDistance>` to `Box<dyn DistanceMeasure>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":3925,"byte_end":3927,"line_start":105,"line_end":105,"column_start":36,"column_end":38,"is_primary":true,"text":[{"text":"        \"AbsDotProductDistance\" => Ok(Box::new(AbsDotProductDistance::new())),","highlight_start":36,"highlight_end":38}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:105:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m105\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"AbsDotProductDistance\" => Ok(Box::new(AbsDotProductDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":3925,"byte_end":3967,"line_start":105,"line_end":105,"column_start":36,"column_end":78,"is_primary":true,"text":[{"text":"        \"AbsDotProductDistance\" => Ok(Box::new(AbsDotProductDistance::new())),","highlight_start":36,"highlight_end":78}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:105:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m105\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"AbsDotProductDistance\" => Ok(Box::new(AbsDotProductDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":3996,"byte_end":4023,"line_start":106,"line_end":106,"column_start":28,"column_end":55,"is_primary":true,"text":[{"text":"        \"L2Distance\" => Ok(Box::new(L2Distance::new())),","highlight_start":28,"highlight_end":55}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `Box<L2Distance>` to `Box<dyn DistanceMeasure>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:106:28\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m106\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"L2Distance\" => Ok(Box::new(L2Distance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for the cast from `Box<L2Distance>` to `Box<dyn DistanceMeasure>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":3993,"byte_end":3995,"line_start":106,"line_end":106,"column_start":25,"column_end":27,"is_primary":true,"text":[{"text":"        \"L2Distance\" => Ok(Box::new(L2Distance::new())),","highlight_start":25,"highlight_end":27}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:106:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m106\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"L2Distance\" => Ok(Box::new(L2Distance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":3993,"byte_end":4024,"line_start":106,"line_end":106,"column_start":25,"column_end":56,"is_primary":true,"text":[{"text":"        \"L2Distance\" => Ok(Box::new(L2Distance::new())),","highlight_start":25,"highlight_end":56}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:106:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m106\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"L2Distance\" => Ok(Box::new(L2Distance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4060,"byte_end":4094,"line_start":107,"line_end":107,"column_start":35,"column_end":69,"is_primary":true,"text":[{"text":"        \"SquaredL2Distance\" => Ok(Box::new(SquaredL2Distance::new())),","highlight_start":35,"highlight_end":69}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `Box<SquaredL2Distance>` to `Box<dyn DistanceMeasure>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:107:35\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m107\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"SquaredL2Distance\" => Ok(Box::new(SquaredL2Distance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for the cast from `Box<SquaredL2Distance>` to `Box<dyn DistanceMeasure>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4057,"byte_end":4059,"line_start":107,"line_end":107,"column_start":32,"column_end":34,"is_primary":true,"text":[{"text":"        \"SquaredL2Distance\" => Ok(Box::new(SquaredL2Distance::new())),","highlight_start":32,"highlight_end":34}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:107:32\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m107\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"SquaredL2Distance\" => Ok(Box::new(SquaredL2Distance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4057,"byte_end":4095,"line_start":107,"line_end":107,"column_start":32,"column_end":70,"is_primary":true,"text":[{"text":"        \"SquaredL2Distance\" => Ok(Box::new(SquaredL2Distance::new())),","highlight_start":32,"highlight_end":70}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:107:32\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m107\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"SquaredL2Distance\" => Ok(Box::new(SquaredL2Distance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4138,"byte_end":4179,"line_start":108,"line_end":108,"column_start":42,"column_end":83,"is_primary":true,"text":[{"text":"        \"NegatedSquaredL2Distance\" => Ok(Box::new(NegatedSquaredL2Distance::new())),","highlight_start":42,"highlight_end":83}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `Box<NegatedSquaredL2Distance>` to `Box<dyn DistanceMeasure>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:108:42\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"NegatedSquaredL2Distance\" => Ok(Box::new(NegatedSquaredL2Distance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for the cast from `Box<NegatedSquaredL2Distance>` to `Box<dyn DistanceMeasure>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4135,"byte_end":4137,"line_start":108,"line_end":108,"column_start":39,"column_end":41,"is_primary":true,"text":[{"text":"        \"NegatedSquaredL2Distance\" => Ok(Box::new(NegatedSquaredL2Distance::new())),","highlight_start":39,"highlight_end":41}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:108:39\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"NegatedSquaredL2Distance\" => Ok(Box::new(NegatedSquaredL2Distance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4135,"byte_end":4180,"line_start":108,"line_end":108,"column_start":39,"column_end":84,"is_primary":true,"text":[{"text":"        \"NegatedSquaredL2Distance\" => Ok(Box::new(NegatedSquaredL2Distance::new())),","highlight_start":39,"highlight_end":84}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:108:39\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"NegatedSquaredL2Distance\" => Ok(Box::new(NegatedSquaredL2Distance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4209,"byte_end":4236,"line_start":109,"line_end":109,"column_start":28,"column_end":55,"is_primary":true,"text":[{"text":"        \"L1Distance\" => Ok(Box::new(L1Distance::new())),","highlight_start":28,"highlight_end":55}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `Box<L1Distance>` to `Box<dyn DistanceMeasure>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:109:28\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"L1Distance\" => Ok(Box::new(L1Distance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for the cast from `Box<L1Distance>` to `Box<dyn DistanceMeasure>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4206,"byte_end":4208,"line_start":109,"line_end":109,"column_start":25,"column_end":27,"is_primary":true,"text":[{"text":"        \"L1Distance\" => Ok(Box::new(L1Distance::new())),","highlight_start":25,"highlight_end":27}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:109:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"L1Distance\" => Ok(Box::new(L1Distance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4206,"byte_end":4237,"line_start":109,"line_end":109,"column_start":25,"column_end":56,"is_primary":true,"text":[{"text":"        \"L1Distance\" => Ok(Box::new(L1Distance::new())),","highlight_start":25,"highlight_end":56}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:109:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"L1Distance\" => Ok(Box::new(L1Distance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4295,"byte_end":4298,"line_start":110,"line_end":110,"column_start":57,"column_end":60,"is_primary":true,"text":[{"text":"        \"CosineDistance\" => Ok(Box::new(CosineDistance::new())),","highlight_start":57,"highlight_end":60}],"label":"multiple `new` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in an impl for the type `distance_measures::CosineDistance`","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":798,"byte_end":818,"line_start":24,"line_end":24,"column_start":5,"column_end":25,"is_primary":true,"text":[{"text":"    pub fn new() -> Self {","highlight_start":5,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in an impl for the type `distance_measures::CosineDistance`","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1843,"byte_end":1863,"line_start":55,"line_end":55,"column_start":13,"column_end":33,"is_primary":true,"text":[{"text":"            pub fn new() -> Self {","highlight_start":13,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/distance_measures.rs","byte_start":2825,"byte_end":2865,"line_start":83,"line_end":83,"column_start":1,"column_end":41,"is_primary":false,"text":[{"text":"define_distance_measure!(CosineDistance);","highlight_start":1,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"define_distance_measure!","def_site_span":{"file_name":"src/distance_measures.rs","byte_start":1721,"byte_end":1757,"line_start":50,"line_end":50,"column_start":1,"column_end":37,"is_primary":false,"text":[{"text":"macro_rules! define_distance_measure {","highlight_start":1,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:110:57\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m110\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"CosineDistance\" => Ok(Box::new(CosineDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `new` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in an impl for the type `distance_measures::CosineDistance`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:24:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new() -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in an impl for the type `distance_measures::CosineDistance`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:55:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m55\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            pub fn new() -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m83\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mdefine_distance_measure!(CosineDistance);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `define_distance_measure` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4267,"byte_end":4269,"line_start":110,"line_end":110,"column_start":29,"column_end":31,"is_primary":true,"text":[{"text":"        \"CosineDistance\" => Ok(Box::new(CosineDistance::new())),","highlight_start":29,"highlight_end":31}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:110:29\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m110\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"CosineDistance\" => Ok(Box::new(CosineDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4267,"byte_end":4302,"line_start":110,"line_end":110,"column_start":29,"column_end":64,"is_primary":true,"text":[{"text":"        \"CosineDistance\" => Ok(Box::new(CosineDistance::new())),","highlight_start":29,"highlight_end":64}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:110:29\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m110\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"CosineDistance\" => Ok(Box::new(CosineDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4341,"byte_end":4378,"line_start":111,"line_end":111,"column_start":38,"column_end":75,"is_primary":true,"text":[{"text":"        \"BinaryCosineDistance\" => Ok(Box::new(BinaryCosineDistance::new())),","highlight_start":38,"highlight_end":75}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `Box<BinaryCosineDistance>` to `Box<dyn DistanceMeasure>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:111:38\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"BinaryCosineDistance\" => Ok(Box::new(BinaryCosineDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for the cast from `Box<BinaryCosineDistance>` to `Box<dyn DistanceMeasure>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4338,"byte_end":4340,"line_start":111,"line_end":111,"column_start":35,"column_end":37,"is_primary":true,"text":[{"text":"        \"BinaryCosineDistance\" => Ok(Box::new(BinaryCosineDistance::new())),","highlight_start":35,"highlight_end":37}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:111:35\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"BinaryCosineDistance\" => Ok(Box::new(BinaryCosineDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4338,"byte_end":4379,"line_start":111,"line_end":111,"column_start":35,"column_end":76,"is_primary":true,"text":[{"text":"        \"BinaryCosineDistance\" => Ok(Box::new(BinaryCosineDistance::new())),","highlight_start":35,"highlight_end":76}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:111:35\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"BinaryCosineDistance\" => Ok(Box::new(BinaryCosineDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4420,"byte_end":4459,"line_start":112,"line_end":112,"column_start":40,"column_end":79,"is_primary":true,"text":[{"text":"        \"GeneralJaccardDistance\" => Ok(Box::new(GeneralJaccardDistance::new())),","highlight_start":40,"highlight_end":79}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `Box<GeneralJaccardDistance>` to `Box<dyn DistanceMeasure>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:112:40\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"GeneralJaccardDistance\" => Ok(Box::new(GeneralJaccardDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for the cast from `Box<GeneralJaccardDistance>` to `Box<dyn DistanceMeasure>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4417,"byte_end":4419,"line_start":112,"line_end":112,"column_start":37,"column_end":39,"is_primary":true,"text":[{"text":"        \"GeneralJaccardDistance\" => Ok(Box::new(GeneralJaccardDistance::new())),","highlight_start":37,"highlight_end":39}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:112:37\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"GeneralJaccardDistance\" => Ok(Box::new(GeneralJaccardDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4417,"byte_end":4460,"line_start":112,"line_end":112,"column_start":37,"column_end":80,"is_primary":true,"text":[{"text":"        \"GeneralJaccardDistance\" => Ok(Box::new(GeneralJaccardDistance::new())),","highlight_start":37,"highlight_end":80}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:112:37\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"GeneralJaccardDistance\" => Ok(Box::new(GeneralJaccardDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4500,"byte_end":4538,"line_start":113,"line_end":113,"column_start":39,"column_end":77,"is_primary":true,"text":[{"text":"        \"BinaryJaccardDistance\" => Ok(Box::new(BinaryJaccardDistance::new())),","highlight_start":39,"highlight_end":77}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `Box<BinaryJaccardDistance>` to `Box<dyn DistanceMeasure>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:113:39\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"BinaryJaccardDistance\" => Ok(Box::new(BinaryJaccardDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for the cast from `Box<BinaryJaccardDistance>` to `Box<dyn DistanceMeasure>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4497,"byte_end":4499,"line_start":113,"line_end":113,"column_start":36,"column_end":38,"is_primary":true,"text":[{"text":"        \"BinaryJaccardDistance\" => Ok(Box::new(BinaryJaccardDistance::new())),","highlight_start":36,"highlight_end":38}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:113:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"BinaryJaccardDistance\" => Ok(Box::new(BinaryJaccardDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4497,"byte_end":4539,"line_start":113,"line_end":113,"column_start":36,"column_end":78,"is_primary":true,"text":[{"text":"        \"BinaryJaccardDistance\" => Ok(Box::new(BinaryJaccardDistance::new())),","highlight_start":36,"highlight_end":78}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:113:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"BinaryJaccardDistance\" => Ok(Box::new(BinaryJaccardDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4585,"byte_end":4629,"line_start":114,"line_end":114,"column_start":45,"column_end":89,"is_primary":true,"text":[{"text":"        \"LimitedInnerProductDistance\" => Ok(Box::new(LimitedInnerProductDistance::new())),","highlight_start":45,"highlight_end":89}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `Box<LimitedInnerProductDistance>` to `Box<dyn DistanceMeasure>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:114:45\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"LimitedInnerProductDistance\" => Ok(Box::new(LimitedInnerProductDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for the cast from `Box<LimitedInnerProductDistance>` to `Box<dyn DistanceMeasure>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4582,"byte_end":4584,"line_start":114,"line_end":114,"column_start":42,"column_end":44,"is_primary":true,"text":[{"text":"        \"LimitedInnerProductDistance\" => Ok(Box::new(LimitedInnerProductDistance::new())),","highlight_start":42,"highlight_end":44}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:114:42\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"LimitedInnerProductDistance\" => Ok(Box::new(LimitedInnerProductDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4582,"byte_end":4630,"line_start":114,"line_end":114,"column_start":42,"column_end":90,"is_primary":true,"text":[{"text":"        \"LimitedInnerProductDistance\" => Ok(Box::new(LimitedInnerProductDistance::new())),","highlight_start":42,"highlight_end":90}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:114:42\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"LimitedInnerProductDistance\" => Ok(Box::new(LimitedInnerProductDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4671,"byte_end":4710,"line_start":115,"line_end":115,"column_start":40,"column_end":79,"is_primary":true,"text":[{"text":"        \"GeneralHammingDistance\" => Ok(Box::new(GeneralHammingDistance::new())),","highlight_start":40,"highlight_end":79}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `Box<GeneralHammingDistance>` to `Box<dyn DistanceMeasure>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:115:40\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m115\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"GeneralHammingDistance\" => Ok(Box::new(GeneralHammingDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for the cast from `Box<GeneralHammingDistance>` to `Box<dyn DistanceMeasure>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4668,"byte_end":4670,"line_start":115,"line_end":115,"column_start":37,"column_end":39,"is_primary":true,"text":[{"text":"        \"GeneralHammingDistance\" => Ok(Box::new(GeneralHammingDistance::new())),","highlight_start":37,"highlight_end":39}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:115:37\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m115\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"GeneralHammingDistance\" => Ok(Box::new(GeneralHammingDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4668,"byte_end":4711,"line_start":115,"line_end":115,"column_start":37,"column_end":80,"is_primary":true,"text":[{"text":"        \"GeneralHammingDistance\" => Ok(Box::new(GeneralHammingDistance::new())),","highlight_start":37,"highlight_end":80}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:115:37\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m115\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"GeneralHammingDistance\" => Ok(Box::new(GeneralHammingDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4751,"byte_end":4789,"line_start":116,"line_end":116,"column_start":39,"column_end":77,"is_primary":true,"text":[{"text":"        \"BinaryHammingDistance\" => Ok(Box::new(BinaryHammingDistance::new())),","highlight_start":39,"highlight_end":77}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `Box<BinaryHammingDistance>` to `Box<dyn DistanceMeasure>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:116:39\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m116\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"BinaryHammingDistance\" => Ok(Box::new(BinaryHammingDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for the cast from `Box<BinaryHammingDistance>` to `Box<dyn DistanceMeasure>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4748,"byte_end":4750,"line_start":116,"line_end":116,"column_start":36,"column_end":38,"is_primary":true,"text":[{"text":"        \"BinaryHammingDistance\" => Ok(Box::new(BinaryHammingDistance::new())),","highlight_start":36,"highlight_end":38}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:116:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m116\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"BinaryHammingDistance\" => Ok(Box::new(BinaryHammingDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4748,"byte_end":4790,"line_start":116,"line_end":116,"column_start":36,"column_end":78,"is_primary":true,"text":[{"text":"        \"BinaryHammingDistance\" => Ok(Box::new(BinaryHammingDistance::new())),","highlight_start":36,"highlight_end":78}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:116:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m116\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"BinaryHammingDistance\" => Ok(Box::new(BinaryHammingDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4833,"byte_end":4874,"line_start":117,"line_end":117,"column_start":42,"column_end":83,"is_primary":true,"text":[{"text":"        \"NonzeroIntersectDistance\" => Ok(Box::new(NonzeroIntersectDistance::new())),","highlight_start":42,"highlight_end":83}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `Box<NonzeroIntersectDistance>` to `Box<dyn DistanceMeasure>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:117:42\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m117\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"NonzeroIntersectDistance\" => Ok(Box::new(NonzeroIntersectDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for the cast from `Box<NonzeroIntersectDistance>` to `Box<dyn DistanceMeasure>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4830,"byte_end":4832,"line_start":117,"line_end":117,"column_start":39,"column_end":41,"is_primary":true,"text":[{"text":"        \"NonzeroIntersectDistance\" => Ok(Box::new(NonzeroIntersectDistance::new())),","highlight_start":39,"highlight_end":41}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:117:39\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m117\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"NonzeroIntersectDistance\" => Ok(Box::new(NonzeroIntersectDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4830,"byte_end":4875,"line_start":117,"line_end":117,"column_start":39,"column_end":84,"is_primary":true,"text":[{"text":"        \"NonzeroIntersectDistance\" => Ok(Box::new(NonzeroIntersectDistance::new())),","highlight_start":39,"highlight_end":84}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:117:39\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m117\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"NonzeroIntersectDistance\" => Ok(Box::new(NonzeroIntersectDistance::new())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/distance_measures.rs","byte_start":4899,"byte_end":4902,"line_start":119,"line_end":119,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        _ => Err(Box::new(ScannError {","highlight_start":14,"highlight_end":17}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:119:14\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m119\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        _ => Err(Box::new(ScannError {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/retrieval.rs","byte_start":1169,"byte_end":1185,"line_start":35,"line_end":35,"column_start":13,"column_end":29,"is_primary":true,"text":[{"text":"            distance_measure,","highlight_start":13,"highlight_end":29}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retrieval.rs:35:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            distance_measure,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `DistanceMeasure` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/retrieval.rs","byte_start":1594,"byte_end":1794,"line_start":45,"line_end":48,"column_start":28,"column_end":14,"is_primary":true,"text":[{"text":"            let distance = self.distance_measure.compute_distance(","highlight_start":28,"highlight_end":67},{"text":"                &utils::DatapointPtr::new(query_vec.as_slice().to_vec()),","highlight_start":1,"highlight_end":74},{"text":"                &utils::DatapointPtr::new(data_vec.as_slice().to_vec()),","highlight_start":1,"highlight_end":73},{"text":"            );","highlight_start":1,"highlight_end":14}],"label":"`DistanceMeasure` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/distance_measures.rs","byte_start":1518,"byte_end":1533,"line_start":45,"line_end":45,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait DistanceMeasure: Send + Sync {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/distance_measures.rs","byte_start":1556,"byte_end":1572,"line_start":46,"line_end":46,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;","highlight_start":8,"highlight_end":24}],"label":"...because method `compute_distance` has generic type parameters","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `compute_distance` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retrieval.rs:45:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            let distance = self.distance_measure.compute_distance(\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m____________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                &utils::DatapointPtr::new(query_vec.as_slice().to_vec()),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                &utils::DatapointPtr::new(data_vec.as_slice().to_vec()),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m48\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            );\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____________^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`DistanceMeasure` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"dyn-compatible\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/distance_measures.rs:46:8\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait DistanceMeasure: Send + Sync {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn compute_distance<T: Copy + Into<f32>>(&self, a: &utils::DatapointPtr<T>, b: &utils::DatapointPtr<T>) -> f32;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `compute_distance` has generic type parameters\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `compute_distance` to another trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `DistanceMeasure` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/retro/attention.rs","byte_start":2115,"byte_end":2159,"line_start":66,"line_end":66,"column_start":12,"column_end":56,"is_primary":true,"text":[{"text":"        Ok(x.component_div(&norm_clamped) * &self.gamma)","highlight_start":12,"highlight_end":56}],"label":"expected `Matrix<f32, Dyn, Dyn, ...>`, found `Matrix<f32, Const<1>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/retro/attention.rs","byte_start":2112,"byte_end":2114,"line_start":66,"line_end":66,"column_start":9,"column_end":11,"is_primary":false,"text":[{"text":"        Ok(x.component_div(&norm_clamped) * &self.gamma)","highlight_start":9,"highlight_end":11}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Matrix<_, Dyn, Dyn, VecStorage<f32, Dyn, Dyn>>`\n   found struct `Matrix<_, Const<1>, Const<1>, ArrayStorage<f32, 1, 1>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/Users/xaxpmore/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs","byte_start":19708,"byte_end":19710,"line_start":531,"line_end":531,"column_start":5,"column_end":7,"is_primary":true,"text":[{"text":"    Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retro/attention.rs:66:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m66\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Ok(x.component_div(&norm_clamped) * &self.gamma)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Matrix<f32, Dyn, Dyn, ...>`, found `Matrix<f32, Const<1>, ..., ...>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this enum variant are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected struct `Matrix<_, \u001b[0m\u001b[0m\u001b[1m\u001b[35mDyn\u001b[0m\u001b[0m, \u001b[0m\u001b[0m\u001b[1m\u001b[35mDyn\u001b[0m\u001b[0m, \u001b[0m\u001b[0m\u001b[1m\u001b[35mVecStorage<f32, Dyn, Dyn>\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m               found struct `Matrix<_, \u001b[0m\u001b[0m\u001b[1m\u001b[35mConst<1>\u001b[0m\u001b[0m, \u001b[0m\u001b[0m\u001b[1m\u001b[35mConst<1>\u001b[0m\u001b[0m, \u001b[0m\u001b[0m\u001b[1m\u001b[35mArrayStorage<f32, 1, 1>\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: tuple variant defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/xaxpmore/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/result.rs:531:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m531\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `Normal`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/retro/attention.rs","byte_start":2537,"byte_end":2543,"line_start":84,"line_end":84,"column_start":22,"column_end":28,"is_primary":true,"text":[{"text":"        let normal = Normal::new(0.0, 1.0);","highlight_start":22,"highlight_end":28}],"label":"use of undeclared type `Normal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `core::intrinsics::mir::BasicBlock::Normal` and 5 others; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/retro/attention.rs","byte_start":2537,"byte_end":2548,"line_start":84,"line_end":84,"column_start":22,"column_end":33,"is_primary":true,"text":[{"text":"        let normal = Normal::new(0.0, 1.0);","highlight_start":22,"highlight_end":33}],"label":null,"suggested_replacement":"core::intrinsics::mir::BasicBlock","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/retro/attention.rs","byte_start":2537,"byte_end":2548,"line_start":84,"line_end":84,"column_start":22,"column_end":33,"is_primary":true,"text":[{"text":"        let normal = Normal::new(0.0, 1.0);","highlight_start":22,"highlight_end":33}],"label":null,"suggested_replacement":"core::num::FpCategory","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/retro/attention.rs","byte_start":2537,"byte_end":2548,"line_start":84,"line_end":84,"column_start":22,"column_end":33,"is_primary":true,"text":[{"text":"        let normal = Normal::new(0.0, 1.0);","highlight_start":22,"highlight_end":33}],"label":null,"suggested_replacement":"std::intrinsics::mir::BasicBlock","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/retro/attention.rs","byte_start":2537,"byte_end":2548,"line_start":84,"line_end":84,"column_start":22,"column_end":33,"is_primary":true,"text":[{"text":"        let normal = Normal::new(0.0, 1.0);","highlight_start":22,"highlight_end":33}],"label":null,"suggested_replacement":"std::num::FpCategory","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/retro/attention.rs","byte_start":2537,"byte_end":2548,"line_start":84,"line_end":84,"column_start":22,"column_end":33,"is_primary":true,"text":[{"text":"        let normal = Normal::new(0.0, 1.0);","highlight_start":22,"highlight_end":33}],"label":null,"suggested_replacement":"std::path::Component","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `Normal`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retro/attention.rs:84:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m84\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let normal = Normal::new(0.0, 1.0);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared type `Normal`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is an enum variant `core::intrinsics::mir::BasicBlock::Normal` and 5 others; try using the variant's enum\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m84\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let normal = \u001b[0m\u001b[0m\u001b[38;5;10mcore::intrinsics::mir::BasicBlock\u001b[0m\u001b[0m(0.0, 1.0);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m84\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let normal = \u001b[0m\u001b[0m\u001b[38;5;10mcore::num::FpCategory\u001b[0m\u001b[0m(0.0, 1.0);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m84\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let normal = \u001b[0m\u001b[0m\u001b[38;5;10mstd::intrinsics::mir::BasicBlock\u001b[0m\u001b[0m(0.0, 1.0);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m84\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let normal = \u001b[0m\u001b[0m\u001b[38;5;10mstd::num::FpCategory\u001b[0m\u001b[0m(0.0, 1.0);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[0m     and 1 other candidate\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared crate or module `rand`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/retro/attention.rs","byte_start":2582,"byte_end":2586,"line_start":85,"line_end":85,"column_start":23,"column_end":27,"is_primary":true,"text":[{"text":"        let mut rng = rand::thread_rng();","highlight_start":23,"highlight_end":27}],"label":"use of undeclared crate or module `rand`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of undeclared crate or module `rand`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retro/attention.rs:85:23\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m85\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut rng = rand::thread_rng();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `rand`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `reshape` found for struct `Matrix` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/retro/decoder.rs","byte_start":1844,"byte_end":1851,"line_start":55,"line_end":55,"column_start":19,"column_end":26,"is_primary":true,"text":[{"text":"        let x = x.reshape((num_chunks, chunk_size, x.ncols()));","highlight_start":19,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a method `shape` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"/Users/xaxpmore/.cargo/registry/src/index.crates.io-6f17d22bba15001f/nalgebra-0.32.6/src/base/matrix.rs","byte_start":19895,"byte_end":19932,"line_start":417,"line_end":417,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub fn shape(&self) -> (usize, usize) {","highlight_start":5,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `reshape` found for struct `Matrix` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retro/decoder.rs:55:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m55\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let x = x.reshape((num_chunks, chunk_size, x.ncols()));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `shape` with a similar name, but with different arguments\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/xaxpmore/.cargo/registry/src/index.crates.io-6f17d22bba15001f/nalgebra-0.32.6/src/base/matrix.rs:417:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m417\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn shape(&self) -> (usize, usize) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `reshape` found for reference `&Matrix<f32, Dyn, Dyn, VecStorage<f32, Dyn, Dyn>>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/retro/decoder.rs","byte_start":1920,"byte_end":1927,"line_start":56,"line_end":56,"column_start":31,"column_end":38,"is_primary":true,"text":[{"text":"        let context = context.reshape((num_chunks, context.nrows() / num_chunks, context.ncols()));","highlight_start":31,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a method `shape` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"/Users/xaxpmore/.cargo/registry/src/index.crates.io-6f17d22bba15001f/nalgebra-0.32.6/src/base/matrix.rs","byte_start":19895,"byte_end":19932,"line_start":417,"line_end":417,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub fn shape(&self) -> (usize, usize) {","highlight_start":5,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `reshape` found for reference `&Matrix<f32, Dyn, Dyn, VecStorage<f32, Dyn, Dyn>>` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retro/decoder.rs:56:31\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let context = context.reshape((num_chunks, context.nrows() / num_chunks, context.ncols()));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `shape` with a similar name, but with different arguments\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/xaxpmore/.cargo/registry/src/index.crates.io-6f17d22bba15001f/nalgebra-0.32.6/src/base/matrix.rs:417:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m417\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn shape(&self) -> (usize, usize) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `reshape` found for struct `Matrix` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/retro/decoder.rs","byte_start":2094,"byte_end":2101,"line_start":58,"line_end":58,"column_start":23,"column_end":30,"is_primary":true,"text":[{"text":"        let out = out.reshape((seq_index, x.ncols()));","highlight_start":23,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a method `shape` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"/Users/xaxpmore/.cargo/registry/src/index.crates.io-6f17d22bba15001f/nalgebra-0.32.6/src/base/matrix.rs","byte_start":19895,"byte_end":19932,"line_start":417,"line_end":417,"column_start":5,"column_end":42,"is_primary":true,"text":[{"text":"    pub fn shape(&self) -> (usize, usize) {","highlight_start":5,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `reshape` found for struct `Matrix` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retro/decoder.rs:58:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m58\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let out = out.reshape((seq_index, x.ncols()));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `shape` with a similar name, but with different arguments\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/xaxpmore/.cargo/registry/src/index.crates.io-6f17d22bba15001f/nalgebra-0.32.6/src/base/matrix.rs:417:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m417\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn shape(&self) -> (usize, usize) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/retro/decoder.rs","byte_start":4681,"byte_end":4700,"line_start":120,"line_end":120,"column_start":81,"column_end":100,"is_primary":true,"text":[{"text":"                x = cross_attn.forward(&x, retrieved_encoded.as_ref().unwrap(), &cross_attn_pos_emb)? + &x;","highlight_start":81,"highlight_end":100}],"label":"expected `(&Matrix<f32, Dyn, Dyn, ...>, ...)`, found `&(Matrix<f32, Dyn, Dyn, ...>, ...)`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/retro/decoder.rs","byte_start":4632,"byte_end":4639,"line_start":120,"line_end":120,"column_start":32,"column_end":39,"is_primary":false,"text":[{"text":"                x = cross_attn.forward(&x, retrieved_encoded.as_ref().unwrap(), &cross_attn_pos_emb)? + &x;","highlight_start":32,"highlight_end":39}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":" expected tuple `(&Matrix<_, _, _, _>, &Matrix<_, _, _, _>)`\nfound reference `&(Matrix<_, _, _, _>, Matrix<_, _, _, _>)`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"src/retro/decoder.rs","byte_start":1193,"byte_end":1232,"line_start":39,"line_end":39,"column_start":9,"column_end":48,"is_primary":false,"text":[{"text":"        pos_emb: (&DMatrix<f32>, &DMatrix<f32>),","highlight_start":9,"highlight_end":48}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/retro/decoder.rs","byte_start":1103,"byte_end":1110,"line_start":35,"line_end":35,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"    pub fn forward(","highlight_start":12,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retro/decoder.rs:120:81\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m120\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                x = cross_attn.forward(&x, retrieved_encoded.as_ref().unwrap(), &cross_attn_pos_emb)? + &x;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this method are incorrect\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `(&Matrix<f32, Dyn, Dyn, ...>, ...)`, found `&(Matrix<f32, Dyn, Dyn, ...>, ...)`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m:  expected tuple `(\u001b[0m\u001b[0m\u001b[1m\u001b[35m&\u001b[0m\u001b[0mMatrix<_, _, _, _>, \u001b[0m\u001b[0m\u001b[1m\u001b[35m&\u001b[0m\u001b[0mMatrix<_, _, _, _>)`\u001b[0m\n\u001b[0m            found reference `\u001b[0m\u001b[0m\u001b[1m\u001b[35m&\u001b[0m\u001b[0m(Matrix<_, _, _, _>, Matrix<_, _, _, _>)`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: method defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retro/decoder.rs:35:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn forward(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m39\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        pos_emb: (&DMatrix<f32>, &DMatrix<f32>),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared crate or module `rand`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/retro/embeddings.rs","byte_start":959,"byte_end":963,"line_start":28,"line_end":28,"column_start":23,"column_end":27,"is_primary":true,"text":[{"text":"        let mut rng = rand::thread_rng();","highlight_start":23,"highlight_end":27}],"label":"use of undeclared crate or module `rand`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of undeclared crate or module `rand`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retro/embeddings.rs:28:23\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m28\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut rng = rand::thread_rng();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `rand`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared crate or module `rand`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/retro/embeddings.rs","byte_start":1973,"byte_end":1977,"line_start":57,"line_end":57,"column_start":23,"column_end":27,"is_primary":true,"text":[{"text":"        let mut rng = rand::thread_rng();","highlight_start":23,"highlight_end":27}],"label":"use of undeclared crate or module `rand`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of undeclared crate or module `rand`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retro/embeddings.rs:57:23\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut rng = rand::thread_rng();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `rand`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `Normal`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/retro/encoder.rs","byte_start":914,"byte_end":920,"line_start":30,"line_end":30,"column_start":22,"column_end":28,"is_primary":true,"text":[{"text":"        let normal = Normal::new(0.0, 1.0);","highlight_start":22,"highlight_end":28}],"label":"use of undeclared type `Normal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an enum variant `core::intrinsics::mir::BasicBlock::Normal` and 5 others; try using the variant's enum","code":null,"level":"help","spans":[{"file_name":"src/retro/encoder.rs","byte_start":914,"byte_end":925,"line_start":30,"line_end":30,"column_start":22,"column_end":33,"is_primary":true,"text":[{"text":"        let normal = Normal::new(0.0, 1.0);","highlight_start":22,"highlight_end":33}],"label":null,"suggested_replacement":"core::intrinsics::mir::BasicBlock","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/retro/encoder.rs","byte_start":914,"byte_end":925,"line_start":30,"line_end":30,"column_start":22,"column_end":33,"is_primary":true,"text":[{"text":"        let normal = Normal::new(0.0, 1.0);","highlight_start":22,"highlight_end":33}],"label":null,"suggested_replacement":"core::num::FpCategory","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/retro/encoder.rs","byte_start":914,"byte_end":925,"line_start":30,"line_end":30,"column_start":22,"column_end":33,"is_primary":true,"text":[{"text":"        let normal = Normal::new(0.0, 1.0);","highlight_start":22,"highlight_end":33}],"label":null,"suggested_replacement":"std::intrinsics::mir::BasicBlock","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/retro/encoder.rs","byte_start":914,"byte_end":925,"line_start":30,"line_end":30,"column_start":22,"column_end":33,"is_primary":true,"text":[{"text":"        let normal = Normal::new(0.0, 1.0);","highlight_start":22,"highlight_end":33}],"label":null,"suggested_replacement":"std::num::FpCategory","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/retro/encoder.rs","byte_start":914,"byte_end":925,"line_start":30,"line_end":30,"column_start":22,"column_end":33,"is_primary":true,"text":[{"text":"        let normal = Normal::new(0.0, 1.0);","highlight_start":22,"highlight_end":33}],"label":null,"suggested_replacement":"std::path::Component","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `Normal`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retro/encoder.rs:30:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m30\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let normal = Normal::new(0.0, 1.0);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared type `Normal`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is an enum variant `core::intrinsics::mir::BasicBlock::Normal` and 5 others; try using the variant's enum\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m30\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let normal = \u001b[0m\u001b[0m\u001b[38;5;10mcore::intrinsics::mir::BasicBlock\u001b[0m\u001b[0m(0.0, 1.0);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m30\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let normal = \u001b[0m\u001b[0m\u001b[38;5;10mcore::num::FpCategory\u001b[0m\u001b[0m(0.0, 1.0);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m30\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let normal = \u001b[0m\u001b[0m\u001b[38;5;10mstd::intrinsics::mir::BasicBlock\u001b[0m\u001b[0m(0.0, 1.0);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m30\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let normal = \u001b[0m\u001b[0m\u001b[38;5;10mstd::num::FpCategory\u001b[0m\u001b[0m(0.0, 1.0);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[0m     and 1 other candidate\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared crate or module `rand`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/retro/encoder.rs","byte_start":959,"byte_end":963,"line_start":31,"line_end":31,"column_start":23,"column_end":27,"is_primary":true,"text":[{"text":"        let mut rng = rand::thread_rng();","highlight_start":23,"highlight_end":27}],"label":"use of undeclared crate or module `rand`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of undeclared crate or module `rand`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retro/encoder.rs:31:23\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut rng = rand::thread_rng();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `rand`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared crate or module `rand`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/retro/model.rs","byte_start":1441,"byte_end":1445,"line_start":43,"line_end":43,"column_start":24,"column_end":28,"is_primary":true,"text":[{"text":"                |_, _| rand::random::<f32>(),","highlight_start":24,"highlight_end":28}],"label":"use of undeclared crate or module `rand`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of undeclared crate or module `rand`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retro/model.rs:43:24\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m43\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                |_, _| rand::random::<f32>(),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `rand`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared crate or module `rand`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/retro/model.rs","byte_start":2506,"byte_end":2510,"line_start":71,"line_end":71,"column_start":24,"column_end":28,"is_primary":true,"text":[{"text":"                |_, _| rand::random::<f32>(),","highlight_start":24,"highlight_end":28}],"label":"use of undeclared crate or module `rand`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of undeclared crate or module `rand`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retro/model.rs:71:24\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                |_, _| rand::random::<f32>(),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `rand`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot index into a value of type `f32`","code":{"code":"E0608","explanation":"An attempt to use index on a type which doesn't implement the `std::ops::Index`\ntrait was performed.\n\nErroneous code example:\n\n```compile_fail,E0608\n0u8[2]; // error: cannot index into a value of type `u8`\n```\n\nTo be able to index into a type it needs to implement the `std::ops::Index`\ntrait. Example:\n\n```\nlet v: Vec<u8> = vec![0, 1, 2, 3];\n\n// The `Vec` type implements the `Index` trait so you can do:\nprintln!(\"{}\", v[2]);\n```\n"},"level":"error","spans":[{"file_name":"src/retro/model.rs","byte_start":4360,"byte_end":4394,"line_start":113,"line_end":113,"column_start":78,"column_end":112,"is_primary":true,"text":[{"text":"                |i, j| retrieved_data[i][j / retrieved_data[0][0].ncols()][0][j % retrieved_data[0][0].ncols()],","highlight_start":78,"highlight_end":112}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0608]\u001b[0m\u001b[0m\u001b[1m: cannot index into a value of type `f32`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/retro/model.rs:113:78\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                |i, j| retrieved_data[i][j / retrieved_data[0][0].ncols()][0][j % retrieved_data[0][0].ncols()],\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot transmute between types of different sizes, or dependently-sized types","code":{"code":"E0512","explanation":"Transmute with two differently sized types was attempted.\n\nErroneous code example:\n\n```compile_fail,E0512\nfn takes_u8(_: u8) {}\n\nfn main() {\n    unsafe { takes_u8(::std::mem::transmute(0u16)); }\n    // error: cannot transmute between types of different sizes,\n    //        or dependently-sized types\n}\n```\n\nPlease use types with same size or use the expected type directly. Example:\n\n```\nfn takes_u8(_: u8) {}\n\nfn main() {\n    unsafe { takes_u8(::std::mem::transmute(0i8)); } // ok!\n    // or:\n    unsafe { takes_u8(0u8); } // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src/serialize.rs","byte_start":973,"byte_end":992,"line_start":25,"line_end":25,"column_start":27,"column_end":46,"is_primary":true,"text":[{"text":"    let n: u32 = unsafe { std::mem::transmute(f) };","highlight_start":27,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"source type: `FloatType` (this type does not have a fixed size)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"target type: `u32` (32 bits)","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0512]\u001b[0m\u001b[0m\u001b[1m: cannot transmute between types of different sizes, or dependently-sized types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/serialize.rs:25:27\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let n: u32 = unsafe { std::mem::transmute(f) };\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: source type: `FloatType` (this type does not have a fixed size)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: target type: `u32` (32 bits)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot transmute between types of different sizes, or dependently-sized types","code":{"code":"E0512","explanation":"Transmute with two differently sized types was attempted.\n\nErroneous code example:\n\n```compile_fail,E0512\nfn takes_u8(_: u8) {}\n\nfn main() {\n    unsafe { takes_u8(::std::mem::transmute(0u16)); }\n    // error: cannot transmute between types of different sizes,\n    //        or dependently-sized types\n}\n```\n\nPlease use types with same size or use the expected type directly. Example:\n\n```\nfn takes_u8(_: u8) {}\n\nfn main() {\n    unsafe { takes_u8(::std::mem::transmute(0i8)); } // ok!\n    // or:\n    unsafe { takes_u8(0u8); } // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src/serialize.rs","byte_start":1522,"byte_end":1541,"line_start":46,"line_end":46,"column_start":14,"column_end":33,"is_primary":true,"text":[{"text":"    unsafe { std::mem::transmute(adjusted) }","highlight_start":14,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"source type: `u32` (32 bits)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"target type: `FloatType` (this type does not have a fixed size)","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0512]\u001b[0m\u001b[0m\u001b[1m: cannot transmute between types of different sizes, or dependently-sized types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/serialize.rs:46:14\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    unsafe { std::mem::transmute(adjusted) }\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: source type: `u32` (32 bits)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: target type: `FloatType` (this type does not have a fixed size)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `u32: From<f32>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/serialize.rs","byte_start":3113,"byte_end":3116,"line_start":106,"line_end":106,"column_start":33,"column_end":36,"is_primary":true,"text":[{"text":"    let n = uint_from_ieee754::<f32, u32>(x);","highlight_start":33,"highlight_end":36}],"label":"the trait `From<f32>` is not implemented for `u32`, which is required by `f32: Into<u32>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `From<T>`:\n  `u32` implements `From<Char>`\n  `u32` implements `From<Ipv4Addr>`\n  `u32` implements `From<bool>`\n  `u32` implements `From<char>`\n  `u32` implements `From<u16>`\n  `u32` implements `From<u8>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `f32` to implement `Into<u32>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `uint_from_ieee754`","code":null,"level":"note","spans":[{"file_name":"src/serialize.rs","byte_start":743,"byte_end":760,"line_start":20,"line_end":20,"column_start":4,"column_end":21,"is_primary":false,"text":[{"text":"fn uint_from_ieee754<FloatType, UintType>(f: FloatType) -> UintType","highlight_start":4,"highlight_end":21}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/serialize.rs","byte_start":829,"byte_end":838,"line_start":22,"line_end":22,"column_start":16,"column_end":25,"is_primary":true,"text":[{"text":"    FloatType: Into<u32> + Copy,","highlight_start":16,"highlight_end":25}],"label":"required by this bound in `uint_from_ieee754`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `u32: From<f32>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/serialize.rs:106:33\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m106\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let n = uint_from_ieee754::<f32, u32>(x);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `From<f32>` is not implemented for `u32`, which is required by `f32: Into<u32>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m              `u32` implements `From<Char>`\u001b[0m\n\u001b[0m              `u32` implements `From<Ipv4Addr>`\u001b[0m\n\u001b[0m              `u32` implements `From<bool>`\u001b[0m\n\u001b[0m              `u32` implements `From<char>`\u001b[0m\n\u001b[0m              `u32` implements `From<u16>`\u001b[0m\n\u001b[0m              `u32` implements `From<u8>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `f32` to implement `Into<u32>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `uint_from_ieee754`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/serialize.rs:22:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m20\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mfn uint_from_ieee754<FloatType, UintType>(f: FloatType) -> UintType\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mwhere\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m22\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    FloatType: Into<u32> + Copy,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `uint_from_ieee754`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `f32: From<u32>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/serialize.rs","byte_start":3409,"byte_end":3412,"line_start":119,"line_end":119,"column_start":28,"column_end":31,"is_primary":true,"text":[{"text":"    Ok(ieee754_from_uint::<f32, u32>(n))","highlight_start":28,"highlight_end":31}],"label":"the trait `From<u32>` is not implemented for `f32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `From<T>`:\n  `f32` implements `From<bool>`\n  `f32` implements `From<i16>`\n  `f32` implements `From<i8>`\n  `f32` implements `From<u16>`\n  `f32` implements `From<u8>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ieee754_from_uint`","code":null,"level":"note","spans":[{"file_name":"src/serialize.rs","byte_start":1154,"byte_end":1171,"line_start":34,"line_end":34,"column_start":4,"column_end":21,"is_primary":false,"text":[{"text":"fn ieee754_from_uint<FloatType, UintType>(n: UintType) -> FloatType","highlight_start":4,"highlight_end":21}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/serialize.rs","byte_start":1338,"byte_end":1347,"line_start":37,"line_end":37,"column_start":16,"column_end":25,"is_primary":true,"text":[{"text":"    FloatType: From<u32>,","highlight_start":16,"highlight_end":25}],"label":"required by this bound in `ieee754_from_uint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `f32: From<u32>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/serialize.rs:119:28\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m119\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Ok(ieee754_from_uint::<f32, u32>(n))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `From<u32>` is not implemented for `f32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m              `f32` implements `From<bool>`\u001b[0m\n\u001b[0m              `f32` implements `From<i16>`\u001b[0m\n\u001b[0m              `f32` implements `From<i8>`\u001b[0m\n\u001b[0m              `f32` implements `From<u16>`\u001b[0m\n\u001b[0m              `f32` implements `From<u8>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ieee754_from_uint`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/serialize.rs:37:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mfn ieee754_from_uint<FloatType, UintType>(n: UintType) -> FloatType\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m37\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    FloatType: From<u32>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `ieee754_from_uint`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `std::io::Write`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/assets.rs","byte_start":721,"byte_end":735,"line_start":20,"line_end":20,"column_start":5,"column_end":19,"is_primary":true,"text":[{"text":"use std::io::Write;","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `std::io::Write`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/assets.rs:20:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m20\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::io::Write;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 108 previous errors; 4 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 108 previous errors; 4 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0034, E0038, E0119, E0277, E0308, E0412, E0422, E0428, E0432...","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0034, E0038, E0119, E0277, E0308, E0412, E0422, E0428, E0432...\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0034`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0034`.\u001b[0m\n"}
